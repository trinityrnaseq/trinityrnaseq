---
title: "Estimate number of transcripts via expression"
author: "bhaas"
date: '2023-02-03'
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(StereoMorph)
```

```{r}
E_inputs_filename = "TrinityDN.salmon.isoform.TMM.EXPR.matrix.E-inputs"


```



```{r}


data = read.table(E_inputs_filename, header=T, com='', sep="\t", stringsAsFactors = F)

data = data %>% filter(max_expr_over_samples > 0.05) # must have some evidence of expression

data = data %>% arrange(desc(max_expr_over_samples)) %>% mutate(r=row_number())

#data$max_expr_over_samples = as.numeric(smooth(data$max_expr_over_samples))

data = data %>% 
  mutate(logexpr = log2(max_expr_over_samples+1)) 


p1 = data %>%
  ggplot(aes(x=logexpr, y=r)) + geom_point() + ggtitle("logexpr ~ ordered_transcript_id")

p1

```



```{r}

normalize = function(x) {
  
  x = unlist(x)
  min_x = min(x)
  max_x = max(x)
  
  message("min_x: ", min_x, " max_x: ", max_x)
  
  vals =  (x-min_x)/(max_x-min_x)
  return(vals)
}


data$x = normalize(list(data$logexpr))
data$y = normalize(list(data$r))


```


```{r}


plot(data$x, data$y)


```




```{r}

# derived from https://github.com/ropensci/pathviewr/blob/HEAD/R/analytical_functions.R

get_dist_point_line <- function(point,
                                line_coord1,
                                line_coord2) {

    ## Compute
    v1 <- line_coord1 - line_coord2
    v2 <- point - line_coord1
    m <- cbind(v1, v2)
    dist <- abs(det(m)) / sqrt(sum(v1 * v1))
  
  ## export
  return(dist)
}



```




```{r}

data = data %>% arrange(x)
first_pt = data %>% head(n=1)
last_pt = data %>% tail(n=1)

#plot(sim_df$x, sim_df$y)

#points(first_pt$x, first_pt$y, col='green')
#points(last_pt$x, last_pt$y, col='green')

xs = c(first_pt$x, last_pt$x)
ys = c(first_pt$y, last_pt$y)


line = lm(ys ~ xs)
coeffs = coefficients(line)
intercept = coeffs[1]
slope = coeffs[2]
#abline(a=intercept,b=slope,col='green')


proj_n_dist = apply(data.frame(x=data$x, y=data$y), 1, function(row) { 
  #message(row)
  x = row[1]
  y = row[2]
  proj = orthogonalProjectionToLine(p=c(x,y), l1=list(m=slope, b=intercept))
  point_dist = get_dist_point_line(c(x,y), c(first_pt$x, first_pt$y), c(last_pt$x, last_pt$y))
  
  return(data.frame(proj_x = proj[1], proj_y = proj[2], dist=point_dist))
  
  })


proj_n_dist_df = do.call(bind_rows, proj_n_dist)

data = bind_cols(data, proj_n_dist_df)

```


```{r}


data %>% ggplot() + geom_point(aes(x=x, y=y), color='orange') +
  geom_point(aes(proj_x, proj_y), color='blue') 


```

```{r}

data %>% ggplot() + geom_point(aes(x=x, y=dist))


```


```{r}

threshold_entry = data %>% arrange(desc(dist)) %>% head(n=1) 

x = threshold_entry$x

x
```


```{r}

data %>% ggplot() + geom_point(aes(x=x, y=y), color='orange') +
  geom_point(aes(proj_x, proj_y), color='blue') +
  geom_vline(xintercept=x)


```


```{r}


tpm_x = threshold_entry$max_expr_over_samples

tpm_x

```



```{r}

# estimate ExN50 based on that threshold and number of transcripts

filtered_data = data %>% filter(max_expr_over_samples >= tpm_x) %>% arrange(desc(length))
sum_length = sum(filtered_data$length)
filtered_data = filtered_data %>% mutate(cumsum_len = cumsum(length))
half_length = sum_length / 2
N50_entry = filtered_data %>% filter(cumsum_len <= half_length) %>% filter(row_number() == n())
Ex = threshold_entry %>% pull(X.Ex)
N50 = N50_entry %>% pull(length)

num_transcripts =  data %>% filter(max_expr_over_samples >= tpm_x) %>% nrow()

p = data %>% ggplot(aes(x=logexpr, y=r)) + geom_point() +
  geom_vline(xintercept=threshold_entry$logexpr, color='red') + 
  annotate("text", x=threshold_entry$logexpr, y=num_transcripts, 
           label=paste0("    # transcripts =", num_transcripts, " Ex=", Ex, " N50=", N50), hjust=0)

p

```


